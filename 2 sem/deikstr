a <- matrix(c(), nrow = 1, ncol = 1, byrow = TRUE) // матрица связей
  d[ <- c() // минимальное расстояние
  v <- c() // посещенные вершины
  minindex <- 0 
  min <- 0
  begin_index <- 0;
  // Вывод матрицы связей
  print(matrix)
  //Инициализация вершин и расстояний
  for (i = 0:length(d)))
  {
    d[i] = 10000
    v[i] = 1
  }
  d[begin_index] = 0;
  // Шаг алгоритма
  repeat {
    minindex = 10000;
    min = 10000;
    for (int i = 0; i<SIZE; i++)
    { // Если вершину ещё не обошли и вес меньше min
      if ((v[i] == 1) && (d[i]<min))
      { // Переприсваиваем значения
        min = d[i];
        minindex = i;
      }
    }
    // Добавляем найденный минимальный вес
    // к текущему весу вершины
    // и сравниваем с текущим минимальным весом вершины
    if (minindex != 10000)
    {
      for (int i = 0; i<SIZE; i++)
      {
        if (a[minindex][i] > 0)
        {
          temp = min + a[minindex][i];
          if (temp < d[i])
          {
            d[i] = temp;
          }
        }
      }
      v[minindex] = 0;
    }
  if(minindex < 10000)
  } 
  // Вывод кратчайших расстояний до вершин
  print(d)
  e <- c() // массив посещенных вершин
  end <- 4 // индекс конечной вершины = 5 - 1
  ver[0] <- end + 1; // начальный элемент - конечная вершина
  k <- 1; // индекс предыдущей вершины
  weight <- d[end] // вес конечной вершины

  while (end != begin_index) // пока не дошли до начальной вершины
  {
    for (i = 0:length(d)) // просматриваем все вершины
      if (a[i][end] != 0)   // если связь есть
      {
        temp = weight - a[i][end]// определяем вес пути из предыдущей вершины
        if (temp == d[i]) // если вес совпал с рассчитанным
        {                 // значит из этой вершины и был переход
          weight = temp // сохраняем новый вес
          end = i // сохраняем предыдущую вершину
          ver[k] = i + 1 // и записываем ее в массив
          k<-k+1
        }
      }
  }
  // Вывод пути (начальная вершина оказалась в конце массива из k элементов)
  
  print(ver)
  

